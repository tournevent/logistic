package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/tournevent/logistic/internal/graphql/generated"
	"github.com/tournevent/logistic/pkg/shipper"
	"go.uber.org/zap"
)

// DelivroGetQuote implements the delivro_get_quote mutation.
func (r *mutationResolver) DelivroGetQuote(ctx context.Context, input generated.GetQuoteInput) (*generated.QuoteResponse, error) {
	requestID := uuid.New().String()
	startTime := time.Now()

	r.Logger.Info("Getting quotes",
		zap.String("request_id", requestID),
		zap.String("shipper_id", input.ShipperID),
	)

	// Convert input to shipper request
	req := &shipper.QuoteRequest{
		ShipperID:   input.ShipperID,
		Origin:      addressInputToModel(input.Origin),
		Destination: addressInputToModel(input.Destination),
		Packages:    packagesInputToModel(input.Packages),
	}

	if input.Options != nil {
		req.Options = optionsInputToModel(input.Options)
	}

	// Get quotes from carriers
	var responses []*shipper.QuoteResponse
	var errs []error

	if input.Options != nil && len(input.Options.Carriers) > 0 {
		carrierNames := make([]string, len(input.Options.Carriers))
		for i, c := range input.Options.Carriers {
			carrierNames[i] = carrierEnumToName(c)
		}
		responses, errs = r.Registry.GetQuotesFromCarriers(ctx, req, carrierNames)
	} else {
		responses, errs = r.Registry.GetAllQuotes(ctx, req)
	}

	// Log any errors
	for _, err := range errs {
		r.Logger.Warn("Carrier quote error", zap.Error(err))
	}

	// Combine all rates
	var allRates []*generated.RateOption
	var quoteID string
	for _, resp := range responses {
		if quoteID == "" {
			quoteID = resp.QuoteID
		}
		for _, rate := range resp.Rates {
			allRates = append(allRates, rateToGraphQL(&rate))
		}
	}

	// Build response
	metadata := &generated.ResponseMetadata{
		RequestID:   requestID,
		ProcessedAt: time.Now(),
	}

	duration := time.Since(startTime).Seconds()
	r.Metrics.RecordRequest("get_quote", "all", "success", duration)

	return &generated.QuoteResponse{
		Success:  len(allRates) > 0,
		QuoteID:  &quoteID,
		Rates:    allRates,
		Errors:   errorsToGraphQL(errs),
		Metadata: metadata,
	}, nil
}

// DelivroCreateOrder implements the delivro_create_order mutation.
func (r *mutationResolver) DelivroCreateOrder(ctx context.Context, input generated.CreateOrderInput) (*generated.OrderResponse, error) {
	requestID := uuid.New().String()
	startTime := time.Now()

	r.Logger.Info("Creating order",
		zap.String("request_id", requestID),
		zap.String("shipper_id", input.ShipperID),
		zap.String("rate_id", input.RateID),
	)

	// Determine carrier from rate ID prefix
	carrierName := carrierFromRateID(input.RateID)
	carrier, err := r.Registry.Get(carrierName)
	if err != nil {
		return &generated.OrderResponse{
			Success:  false,
			Errors:   []*generated.Error{{Code: "CARRIER_NOT_FOUND", Message: err.Error()}},
			Metadata: &generated.ResponseMetadata{RequestID: requestID, ProcessedAt: time.Now()},
		}, nil
	}

	// Convert input to shipper request
	req := &shipper.CreateOrderRequest{
		ShipperID:        input.ShipperID,
		RateID:           input.RateID,
		Sender:           contactInputToModel(input.Sender),
		SenderAddress:    addressInputToModel(input.SenderAddress),
		Recipient:        contactInputToModel(input.Recipient),
		RecipientAddress: addressInputToModel(input.RecipientAddress),
		Packages:         packagesInputToModel(input.Packages),
	}

	if input.QuoteID != nil {
		req.QuoteID = *input.QuoteID
	}
	if input.Reference != nil {
		req.Reference = *input.Reference
	}
	if input.PoNumber != nil {
		req.PONumber = *input.PoNumber
	}
	if input.Instructions != nil {
		req.Instructions = *input.Instructions
	}

	// Create order
	resp, err := carrier.CreateOrder(ctx, req)
	if err != nil {
		r.Metrics.RecordRequest("create_order", carrierName, "error", time.Since(startTime).Seconds())
		return &generated.OrderResponse{
			Success:  false,
			Errors:   []*generated.Error{{Code: "CREATE_ORDER_FAILED", Message: err.Error()}},
			Metadata: &generated.ResponseMetadata{RequestID: requestID, ProcessedAt: time.Now(), Carrier: carrierNameToEnum(carrierName)},
		}, nil
	}

	r.Metrics.RecordRequest("create_order", carrierName, "success", time.Since(startTime).Seconds())

	return &generated.OrderResponse{
		Success:           true,
		OrderID:           &resp.OrderID,
		TrackingNumber:    &resp.TrackingNumber,
		TrackingURL:       &resp.TrackingURL,
		Status:            statusToEnum(resp.Status),
		Carrier:           carrierNameToEnum(carrierName),
		ServiceName:       &resp.ServiceName,
		TotalCharged:      moneyToGraphQL(&resp.TotalCharged),
		EstimatedDelivery: resp.EstimatedDelivery,
		LabelURL:          &resp.LabelURL,
		Metadata:          &generated.ResponseMetadata{RequestID: requestID, ProcessedAt: time.Now(), Carrier: carrierNameToEnum(carrierName)},
	}, nil
}

// DelivroGetLabel implements the delivro_get_label mutation.
func (r *mutationResolver) DelivroGetLabel(ctx context.Context, input generated.GetLabelInput) (*generated.LabelResponse, error) {
	requestID := uuid.New().String()
	startTime := time.Now()

	r.Logger.Info("Getting label",
		zap.String("request_id", requestID),
		zap.String("order_id", input.OrderID),
	)

	// Determine carrier from order ID prefix
	carrierName := carrierFromOrderID(input.OrderID)
	carrier, err := r.Registry.Get(carrierName)
	if err != nil {
		return &generated.LabelResponse{
			Success:  false,
			Errors:   []*generated.Error{{Code: "CARRIER_NOT_FOUND", Message: err.Error()}},
			Metadata: &generated.ResponseMetadata{RequestID: requestID, ProcessedAt: time.Now()},
		}, nil
	}

	format := shipper.LabelPDF
	if input.Format != nil {
		format = labelFormatToModel(*input.Format)
	}

	req := &shipper.GetLabelRequest{
		OrderID: input.OrderID,
		Format:  format,
	}

	resp, err := carrier.GetLabel(ctx, req)
	if err != nil {
		r.Metrics.RecordRequest("get_label", carrierName, "error", time.Since(startTime).Seconds())
		return &generated.LabelResponse{
			Success:  false,
			Errors:   []*generated.Error{{Code: "GET_LABEL_FAILED", Message: err.Error()}},
			Metadata: &generated.ResponseMetadata{RequestID: requestID, ProcessedAt: time.Now(), Carrier: carrierNameToEnum(carrierName)},
		}, nil
	}

	r.Metrics.RecordRequest("get_label", carrierName, "success", time.Since(startTime).Seconds())

	return &generated.LabelResponse{
		Success:  true,
		OrderID:  &resp.OrderID,
		Label:    labelToGraphQL(&resp.Label),
		Metadata: &generated.ResponseMetadata{RequestID: requestID, ProcessedAt: time.Now(), Carrier: carrierNameToEnum(carrierName)},
	}, nil
}

// DelivroCancelOrder implements the delivro_cancel_order mutation.
func (r *mutationResolver) DelivroCancelOrder(ctx context.Context, input generated.CancelOrderInput) (*generated.CancelResponse, error) {
	requestID := uuid.New().String()
	startTime := time.Now()

	r.Logger.Info("Cancelling order",
		zap.String("request_id", requestID),
		zap.String("order_id", input.OrderID),
	)

	// Determine carrier from order ID prefix
	carrierName := carrierFromOrderID(input.OrderID)
	carrier, err := r.Registry.Get(carrierName)
	if err != nil {
		return &generated.CancelResponse{
			Success:  false,
			Errors:   []*generated.Error{{Code: "CARRIER_NOT_FOUND", Message: err.Error()}},
			Metadata: &generated.ResponseMetadata{RequestID: requestID, ProcessedAt: time.Now()},
		}, nil
	}

	req := &shipper.CancelOrderRequest{
		OrderID: input.OrderID,
	}
	if input.Reason != nil {
		req.Reason = *input.Reason
	}

	resp, err := carrier.CancelOrder(ctx, req)
	if err != nil {
		r.Metrics.RecordRequest("cancel_order", carrierName, "error", time.Since(startTime).Seconds())
		return &generated.CancelResponse{
			Success:  false,
			Errors:   []*generated.Error{{Code: "CANCEL_ORDER_FAILED", Message: err.Error()}},
			Metadata: &generated.ResponseMetadata{RequestID: requestID, ProcessedAt: time.Now(), Carrier: carrierNameToEnum(carrierName)},
		}, nil
	}

	r.Metrics.RecordRequest("cancel_order", carrierName, "success", time.Since(startTime).Seconds())

	return &generated.CancelResponse{
		Success:            true,
		OrderID:            &resp.OrderID,
		Status:             statusToEnum(resp.Status),
		RefundAmount:       moneyToGraphQL(resp.RefundAmount),
		ConfirmationNumber: &resp.ConfirmationNumber,
		Metadata:           &generated.ResponseMetadata{RequestID: requestID, ProcessedAt: time.Now(), Carrier: carrierNameToEnum(carrierName)},
	}, nil
}

// Health implements the health query.
func (r *queryResolver) Health(ctx context.Context) (bool, error) {
	return true, nil
}

// Carriers implements the carriers query.
func (r *queryResolver) Carriers(ctx context.Context) ([]generated.Carrier, error) {
	names := r.Registry.Names()
	carriers := make([]generated.Carrier, 0, len(names))
	for _, name := range names {
		switch name {
		case "freightcom":
			carriers = append(carriers, generated.CarrierFreightcom)
		case "canadapost":
			carriers = append(carriers, generated.CarrierCanadaPost)
		case "purolator":
			carriers = append(carriers, generated.CarrierPurolator)
		}
	}
	return carriers, nil
}

// ServiceTypes implements the serviceTypes query.
func (r *queryResolver) ServiceTypes(ctx context.Context) ([]generated.ServiceType, error) {
	return []generated.ServiceType{
		generated.ServiceTypeStandard,
		generated.ServiceTypeExpress,
		generated.ServiceTypePriority,
		generated.ServiceTypeOvernight,
		generated.ServiceTypeEconomy,
		generated.ServiceTypeFreight,
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
